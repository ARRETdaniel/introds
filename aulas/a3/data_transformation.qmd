---
title: "Transformação de dados"
subtitle: "Introdução à ciência de dados"
author: "Daniel Brito dos Santos"
format: 
  revealjs:
    incremental: false
---

## 4.1 Introdução
- Visualização é uma ferramenta importante para gerar insight, mas raramente os dados estão na **forma** que você precisa

::: {.incremental}
- Frequentemente precisamos:
    - **Criar** novas variáveis
    - Fazer **sumários** para achar padrões importantes
    - **Renomear** variáveis 
    - **Reordenar** observações para facilitar a manipulação
:::

---

- Vamos aprender a fazer tudo isso usando o pacote **dplyr** e um novo dataset com os **voos** que sairam da cidade de **Nova York** em **2013**

- Nosso objetivo é apresentar as principais ferramentas para **transformar** um data frame. 

- Vamos começar com operações em **linhas**, depois em **colunas**

- Terminar com um **estudo de caso** para colocar essas operações em ação

## 4.1.1 Prerequisitos
- O **dplyr** é outro pacote fundamental do tidyverse
- Nosso dataset vai ser o **nycflights13** 

```r
library(nycflights13)
library(tidyverse)
#> ── Attaching packages ──────────────────────────────────── tidyverse 1.3.2 ──
#> ✔ ggplot2 3.4.0           ✔ purrr   1.0.1.9000 
#> ✔ tibble  3.1.8           ✔ dplyr   1.0.99.9000
#> ✔ tidyr   1.2.1.9001      ✔ stringr 1.5.0      
#> ✔ readr   2.1.3           ✔ forcats 0.5.2      
#> ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──
#> ✖ dplyr::filter() masks stats::filter()
#> ✖ dplyr::lag()    masks stats::lag()
```

## 4.1.2 nycflights13
- Vamos usar o dataset *nycflights13::flights*
- Ele contém 336,776 voos que sairam da cidade de Nova York em 2013
- Primeiramente vamos dar uma espiadinha

---

Quais são as formas de visualizar um data set em R? 

. . .

```r
flights 
```

. . .

```r
glimpse(flights) 
```

. . .

```r
view(flights) 
```

---

- É interessante observamos as características gerais dos nossos dados como
    - Nomes de colunas
    - Formato de dados 

---

```r
#| echo: true
glimpse(flights)
```

## 4.1.3 dplyr basics
- Vamos ver os **verbos básicos** que vão nos ajudar a resolver a maior parte dos desafios de **manipulação de dados**

- Todos tem três coisas em comum:
    1. O **primeiro** argumento é sempre um **data frame** (df)
    2. O **segundo** argumento descreve **o que fazer** com o df
    3. O **resultado** é sempre um **novo df**

- Como o primeiro argumento e o resultado são dfs, é muito conveniente usarmos os pipes! (|>)
---

- O pipe pega o que está na esquerda e passa como primeiro argumento da função depois dele:
```r
x |> f(y)
f(x, y)
```
. . .

Como seria nesse caso? 

```r
x |> f(y) |> g(z)
```
. . .

```r
g(f(x, y), z)f(x, y)
```
---
- Quem quer explicar esse código? Só um geralzão!
```r
flights |>
  filter(dest == "IAH") |> 
  group_by(year, month, day) |> 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )
```
. . . 

- O código inicia com o dataset *fligths*, depois ele é **filtrado**, **agrupado** e **sumarizado**.  

. . . 

- E os detalhes?

. . .

- Pegamos os voos, **filtramos** os destinados a "IAH". **Agrupamos** por ano, mes e dia. Finalmente, **sumarizamos** o seu atraso médio. 

---

- Os verbos do dplyr são organizados de acordo com o em que eles operam:
    - linhas, colunas, grupos ou tabelas
- Vamos ver os três primeiros casos, começando com 

## 4.2 Rows 
::: {.incremental}
- Os verbos mais importantes que operam em linhas são:
    - *filter()* - que filtra as linhas desejadas 
    - *arrange()* - que muda a ordem das linhas 
    - NENHUM DOS DOIS MODIFICAM AS COLUNAS
- Também temos: 
    - *distinct()* que encontra linhas com valores únicos, mas pode modificar colunas
:::

## *filter()*
::: {.incremental}
- Essa função mantém as linhas baseado no valor de suas colunas
- O primeiro argumento é um data frame
- Do segundo argumento em diante são **condições** que devem ser **verdadeiras** para **manter a linha**
:::
---

### Por exemplo

- Queremos encontrar todos os voos que chegaram mais de 120 minutos (duas horas) atrasados

- Quem arrisca? 

. . . 

```r
#| echo: true
flights |> 
  filter(arr_delay > 120)
```
---

- E se quisermos ver os voos que sairam dia primeiro de janeiro? 

. . .

```r
#| echo: true
flights |> 
  filter(month == 1 & day == 1)
```
---

- Voos que sairam em janeiro ou fevereiro? 

. . .

```r
#| echo: true
flights |> 
  filter(month == 1 | month == 2)
```
---

- Uma outra forma de fazer "em janeiro ou em fevereiro":
```r
#| echo: true
flights |> 
  filter(month %in% c(1, 2))
```
---

### Salvando o resultado
::: {.incremental}
- Quando executamos `filter()` o dplyr cria e retorna um novo data frame
- Ele **não** modifica o input
- Por que funções *dplyr* **nunca** modificam os inputs 
- Para salvar o resultado precisamos usar o operador de atribuição `<-`:
:::

. . .

```r
jan1 <- flights |> 
  filter(month == 1 & day == 1)
```

## 4.2.2 Erros comuns 

- No início é fácil confundir ``=`` com `==` quando queremos testar igualdade. 

. . .

- O que acham que vai acontecer?

```r
flights |> 
  filter(month = 1)
```
. . . 

```r
#> Error in `filter()`:
#> ! We detected a named input.
#> ℹ This usually means that you've used `=` instead of `==`.
#> ℹ Did you mean `month == 1`?
```
---

- Outro erro comum é usar "ou" como usamos no dia a dia
```r
flights |> 
  filter(month == 1 | 2)
```
. . .

- O que acham que vai acontecer? 

. . . 

- Por que será que aconteceu isso? 

## `arrange()`
::: {.incremental}
- altera a **ordem** das linhas baseado no **valor** de suas **colunas** 
- recebe um **data frame** e um **conjunto** de **nomes de colunas** (ou expressões) como **critérios** de ordenação 
- Cada **novo argumento** é usado para resolver **empates** na ordenação do anterior
:::
---
### Exemplo
- O que esse código faz?
```r
flights |> 
  arrange(year, month, day, dep_time)
```
. . .

- Ordena por ordem de decolagem, que está separada nas quatro variáveis: ano, mês, dia e hora da decolagem

```r
#> # A tibble: 336,776 × 19
#>    year month   day dep_time sched_…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013     1     1      517      515       2     830     819      11 UA     
#> 2  2013     1     1      533      529       4     850     830      20 UA     
#> 3  2013     1     1      542      540       2     923     850      33 AA     
#> 4  2013     1     1      544      545      -1    1004    1022     -18 B6     
#> 5  2013     1     1      554      600      -6     812     837     -25 DL     
#> 6  2013     1     1      554      558      -4     740     728      12 UA     
#> # … with 336,770 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay
```
---
<!-- ### Ordem decrescente -->
- O que acham que esse código faz?
```r
flights |> 
  arrange(desc(dep_delay))
```
. . .

- Podemos usar a função `desc()` para reordenar a coluna em ordem decrescente

---

### Podemos combinar `arrange()` e `filter()` para resolver problemas mais complexos

. . .

- Exemplo:
  - como poderíamos encontrar os voos que **chegaram** **mais atrasados**, mas que **decolaram** mais ou menos na **hora certa**? (esse é mais difícil)

. . .

- Vamos deixar mais exato o "hora certa": 
    - voos que sairam com no máximo 10 minutos de atraso ou adiantamento 
. . .

- (sim, eu também não sabia que voos poderiam sair adiantados)

---

```r
flights |> 
  filter(dep_delay <= 10 & dep_delay >= -10) |> 
  arrange(desc(arr_delay))
#> # A tibble: 239,109 × 19
#>    year month   day dep_time sched_…¹ dep_d…² arr_t…³ sched…⁴ arr_d…⁵ carrier
#>   <int> <int> <int>    <int>    <int>   <dbl>   <int>   <int>   <dbl> <chr>  
#> 1  2013    11     1      658      700      -2    1329    1015     194 VX     
#> 2  2013     4    18      558      600      -2    1149     850     179 AA     
#> 3  2013     7     7     1659     1700      -1    2050    1823     147 US     
#> 4  2013     7    22     1606     1615      -9    2056    1831     145 DL     
#> 5  2013     9    19      648      641       7    1035     810     145 UA     
#> 6  2013     4    18      655      700      -5    1213     950     143 AA     
#> # … with 239,103 more rows, 9 more variables: flight <int>, tailnum <chr>,
#> #   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,
#> #   minute <dbl>, time_hour <dttm>, and abbreviated variable names
#> #   ¹​sched_dep_time, ²​dep_delay, ³​arr_time, ⁴​sched_arr_time, ⁵​arr_delay
```

## 4.2.4 `distinct()`
::: {.incremental}
- Encontra todas as linhas únicas em um dataset
- Como os outros, seu primeiro argumento é o dataset
- Seus próximos argumentos são os **nomes das colunas** que queremos as linhas distintas 
:::

--- 

- O que esse código faz? 
```r
flights |> 
  distinct(origin, dest)
```
. . .

```r
#> # A tibble: 224 × 2
#>   origin dest 
#>   <chr>  <chr>
#> 1 EWR    IAH  
#> 2 LGA    IAH  
#> 3 JFK    MIA  
#> 4 JFK    BQN  
#> 5 LGA    ATL  
#> 6 EWR    ORD  
#> # … with 218 more rows
```
- Encontra todos os pares únicos de `origin` e `dest`

---

- E esse código? 
```r
flights |> 
  distinct()
```
. . . 

::: {.incremental}
- Se não colocarmos nomes, ele **remove** as linhas **duplicadas**
- Pergunta: ele altera o dataset que recebeu de input?
- **não!** Nenhum verbo dplyr altera o dataset original!
:::

<!-- ---

- Observe que se quisermos encontrar o número de duplicatas, ou as linhas que não foram duplicadas devemos substituir o `distict()` pelo `count()` e filtrar conformeo necessário -->

## 4.3 Columns 

::: {.incremental}
- Existem quatro verbos importantes que alteram as colunas sem alterar as linhas
  - `mutate()` - Cria novas colunas partindo de funções das colunas existentes
  - `select()` - Seleciona quais colunas manter no novo dataset
  - `rename()` - Renomea colunas 
  - `relocate()` - Altera a posição das colunas
- Também vamos discutir o `pull()` que permite obter uma coluna do dataset
:::

## `mutate()`
::: {.incremental}
- Adiciona novas colunas que são calculadas das colunas existentes
- Nos capítulos de transformação tem uma série de funções úteis para manipular diferentes tipos de variáveis
- Aquivamos focar na álgebra básica 
::: 



<!-- ------------------------------ -->




---


::: {.incremental}
:::

::: {.incremental}
-

:::



```r
```
